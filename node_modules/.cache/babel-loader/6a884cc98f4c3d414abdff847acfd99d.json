{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { ensureArray, functionalUpdate, isValidTimeout, noop, replaceEqualDeep, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { getLogger } from './logger';\nimport { Retryer, isCancelledError } from './retryer'; // TYPES\n// CLASS\n\nexport var Query = /*#__PURE__*/function () {\n  function Query(config) {\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || this.getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.setOptions = function setOptions(options) {\n    var _this$options$cacheTi;\n\n    this.options = _extends({}, this.defaultOptions, options); // Default to 5 minutes if not cache time is set\n\n    this.cacheTime = Math.max(this.cacheTime || 0, (_this$options$cacheTi = this.options.cacheTime) != null ? _this$options$cacheTi : 5 * 60 * 1000);\n  };\n\n  _proto.setDefaultOptions = function setDefaultOptions(options) {\n    this.defaultOptions = options;\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this = this;\n\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(function () {\n        if (!_this.observers.length) {\n          _this.cache.remove(_this);\n        }\n      }, this.cacheTime);\n    }\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    clearTimeout(this.gcTimeout);\n    this.gcTimeout = undefined;\n  };\n\n  _proto.setData = function setData(updater, options) {\n    var _this$options$isDataE, _this$options;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Use prev data if an isDataEqual function is defined and returns `true`\n\n    if ((_this$options$isDataE = (_this$options = this.options).isDataEqual) == null ? void 0 : _this$options$isDataE.call(_this$options, prevData, data)) {\n      data = prevData;\n    } else if (this.options.structuralSharing !== false) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data);\n    } // Set data and mark it as cached\n\n\n    this.dispatch({\n      data: data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt\n    });\n    return data;\n  };\n\n  _proto.setState = function setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state: state\n    });\n  };\n\n  _proto.cancel = function cancel(options) {\n    var _this$retryer;\n\n    var promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.cancel();\n  };\n\n  _proto.reset = function reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  };\n\n  _proto.isActive = function isActive() {\n    return this.observers.some(function (observer) {\n      return observer.options.enabled !== false;\n    });\n  };\n\n  _proto.isFetching = function isFetching() {\n    return this.state.isFetching;\n  };\n\n  _proto.isStale = function isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (observer) {\n      return observer.getCurrentResult().isStale;\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  };\n\n  _proto.onFocus = function onFocus() {\n    var _this$retryer2;\n\n    var observer = this.observers.find(function (x) {\n      return x.willFetchOnWindowFocus();\n    });\n\n    if (observer) {\n      observer.refetch();\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  };\n\n  _proto.onOnline = function onOnline() {\n    var _this$retryer3;\n\n    var observer = this.observers.find(function (x) {\n      return x.willFetchOnReconnect();\n    });\n\n    if (observer) {\n      observer.refetch();\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  };\n\n  _proto.addObserver = function addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify(this);\n    }\n  };\n\n  _proto.removeObserver = function removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(function (x) {\n        return x !== observer;\n      });\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.retryer.isTransportCancelable) {\n            this.retryer.cancel();\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        if (this.cacheTime) {\n          this.scheduleGc();\n        } else {\n          this.cache.remove(this);\n        }\n      }\n\n      this.cache.notify(this);\n    }\n  };\n\n  _proto.invalidate = function invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  };\n\n  _proto.fetch = function fetch(options, fetchOptions) {\n    var _this2 = this,\n        _this$options$behavio,\n        _context$fetchOptions;\n\n    if (this.state.isFetching) if (this.state.dataUpdatedAt && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {\n      // Silently cancel current fetch if the user wants to cancel refetches\n      this.cancel({\n        silent: true\n      });\n    } else if (this.promise) {\n      // Return current promise if we are already fetching\n      return this.promise;\n    } // Update config if passed, otherwise the config from the last execution is used\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      var observer = this.observers.find(function (x) {\n        return x.options.queryFn;\n      });\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    } // Create query function context\n\n\n    var queryKey = ensureArray(this.queryKey);\n    var queryFnContext = {\n      queryKey: queryKey,\n      pageParam: undefined\n    }; // Create fetch function\n\n    var fetchFn = function fetchFn() {\n      return _this2.options.queryFn ? _this2.options.queryFn(queryFnContext) : Promise.reject('Missing queryFn');\n    }; // Trigger behavior hook\n\n\n    var context = {\n      fetchOptions: fetchOptions,\n      options: this.options,\n      queryKey: queryKey,\n      state: this.state,\n      fetchFn: fetchFn\n    };\n\n    if ((_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch) {\n      var _this$options$behavio2;\n\n      (_this$options$behavio2 = this.options.behavior) == null ? void 0 : _this$options$behavio2.onFetch(context);\n    } // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    } // Try to fetch the data\n\n\n    this.retryer = new Retryer({\n      fn: context.fetchFn,\n      onFail: function onFail() {\n        _this2.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: function onPause() {\n        _this2.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: function onContinue() {\n        _this2.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay\n    });\n    this.promise = this.retryer.promise.then(function (data) {\n      return _this2.setData(data);\n    }).catch(function (error) {\n      // Set error state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        _this2.dispatch({\n          type: 'error',\n          error: error\n        });\n      } // Log error\n\n\n      if (!isCancelledError(error)) {\n        getLogger().error(error);\n      } // Propagate error\n\n\n      throw error;\n    });\n    return this.promise;\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this3 = this;\n\n    this.state = this.reducer(this.state, action);\n    notifyManager.batch(function () {\n      _this3.observers.forEach(function (observer) {\n        observer.onQueryUpdate(action);\n      });\n\n      _this3.cache.notify(_this3);\n    });\n  };\n\n  _proto.getDefaultState = function getDefaultState(options) {\n    var data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n    var hasData = typeof data !== 'undefined';\n    return {\n      data: data,\n      dataUpdateCount: 0,\n      dataUpdatedAt: hasData ? Date.now() : 0,\n      error: null,\n      errorUpdateCount: 0,\n      errorUpdatedAt: 0,\n      fetchFailureCount: 0,\n      fetchMeta: null,\n      isFetching: false,\n      isInvalidated: false,\n      isPaused: false,\n      status: hasData ? 'success' : 'idle'\n    };\n  };\n\n  _proto.reducer = function reducer(state, action) {\n    var _action$meta, _action$dataUpdatedAt;\n\n    switch (action.type) {\n      case 'failed':\n        return _extends({}, state, {\n          fetchFailureCount: state.fetchFailureCount + 1\n        });\n\n      case 'pause':\n        return _extends({}, state, {\n          isPaused: true\n        });\n\n      case 'continue':\n        return _extends({}, state, {\n          isPaused: false\n        });\n\n      case 'fetch':\n        return _extends({}, state, {\n          fetchFailureCount: 0,\n          fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n          isFetching: true,\n          isPaused: false,\n          status: state.status === 'idle' ? 'loading' : state.status\n        });\n\n      case 'success':\n        return _extends({}, state, {\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n          error: null,\n          fetchFailureCount: 0,\n          isFetching: false,\n          isInvalidated: false,\n          isPaused: false,\n          status: 'success'\n        });\n\n      case 'error':\n        var error = action.error;\n\n        if (isCancelledError(error) && error.revert) {\n          return _extends({}, state, {\n            fetchFailureCount: 0,\n            isFetching: false,\n            isPaused: false,\n            status: state.status === 'loading' ? 'idle' : state.status\n          });\n        }\n\n        return _extends({}, state, {\n          error: error,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          isFetching: false,\n          isPaused: false,\n          status: 'error'\n        });\n\n      case 'invalidate':\n        return _extends({}, state, {\n          isInvalidated: true\n        });\n\n      case 'setState':\n        return _extends({}, state, action.state);\n\n      default:\n        return state;\n    }\n  };\n\n  return Query;\n}();","map":{"version":3,"sources":["/Users/alexbennett/Desktop/JOB/err-sketch/node_modules/react-query/es/core/query.js"],"names":["_extends","ensureArray","functionalUpdate","isValidTimeout","noop","replaceEqualDeep","timeUntilStale","notifyManager","getLogger","Retryer","isCancelledError","Query","config","defaultOptions","setOptions","options","observers","cache","queryKey","queryHash","initialState","state","getDefaultState","scheduleGc","_proto","prototype","_this$options$cacheTi","cacheTime","Math","max","setDefaultOptions","_this","clearGcTimeout","gcTimeout","setTimeout","length","remove","clearTimeout","undefined","setData","updater","_this$options$isDataE","_this$options","prevData","data","isDataEqual","call","structuralSharing","dispatch","type","dataUpdatedAt","updatedAt","setState","cancel","_this$retryer","promise","retryer","then","catch","Promise","resolve","destroy","reset","isActive","some","observer","enabled","isFetching","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","onFocus","_this$retryer2","find","x","willFetchOnWindowFocus","refetch","continue","onOnline","_this$retryer3","willFetchOnReconnect","addObserver","indexOf","push","notify","removeObserver","filter","isTransportCancelable","cancelRetry","invalidate","fetch","fetchOptions","_this2","_this$options$behavio","_context$fetchOptions","cancelRefetch","silent","queryFn","queryFnContext","pageParam","fetchFn","reject","context","behavior","onFetch","_this$options$behavio2","fetchMeta","meta","_context$fetchOptions2","fn","onFail","onPause","onContinue","retry","retryDelay","error","action","_this3","reducer","batch","forEach","onQueryUpdate","initialData","hasData","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","fetchFailureCount","isPaused","status","_action$meta","_action$dataUpdatedAt","revert"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { ensureArray, functionalUpdate, isValidTimeout, noop, replaceEqualDeep, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { getLogger } from './logger';\nimport { Retryer, isCancelledError } from './retryer'; // TYPES\n\n// CLASS\nexport var Query = /*#__PURE__*/function () {\n  function Query(config) {\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || this.getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.setOptions = function setOptions(options) {\n    var _this$options$cacheTi;\n\n    this.options = _extends({}, this.defaultOptions, options); // Default to 5 minutes if not cache time is set\n\n    this.cacheTime = Math.max(this.cacheTime || 0, (_this$options$cacheTi = this.options.cacheTime) != null ? _this$options$cacheTi : 5 * 60 * 1000);\n  };\n\n  _proto.setDefaultOptions = function setDefaultOptions(options) {\n    this.defaultOptions = options;\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this = this;\n\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(function () {\n        if (!_this.observers.length) {\n          _this.cache.remove(_this);\n        }\n      }, this.cacheTime);\n    }\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    clearTimeout(this.gcTimeout);\n    this.gcTimeout = undefined;\n  };\n\n  _proto.setData = function setData(updater, options) {\n    var _this$options$isDataE, _this$options;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Use prev data if an isDataEqual function is defined and returns `true`\n\n    if ((_this$options$isDataE = (_this$options = this.options).isDataEqual) == null ? void 0 : _this$options$isDataE.call(_this$options, prevData, data)) {\n      data = prevData;\n    } else if (this.options.structuralSharing !== false) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data);\n    } // Set data and mark it as cached\n\n\n    this.dispatch({\n      data: data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt\n    });\n    return data;\n  };\n\n  _proto.setState = function setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state: state\n    });\n  };\n\n  _proto.cancel = function cancel(options) {\n    var _this$retryer;\n\n    var promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.cancel();\n  };\n\n  _proto.reset = function reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  };\n\n  _proto.isActive = function isActive() {\n    return this.observers.some(function (observer) {\n      return observer.options.enabled !== false;\n    });\n  };\n\n  _proto.isFetching = function isFetching() {\n    return this.state.isFetching;\n  };\n\n  _proto.isStale = function isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (observer) {\n      return observer.getCurrentResult().isStale;\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  };\n\n  _proto.onFocus = function onFocus() {\n    var _this$retryer2;\n\n    var observer = this.observers.find(function (x) {\n      return x.willFetchOnWindowFocus();\n    });\n\n    if (observer) {\n      observer.refetch();\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  };\n\n  _proto.onOnline = function onOnline() {\n    var _this$retryer3;\n\n    var observer = this.observers.find(function (x) {\n      return x.willFetchOnReconnect();\n    });\n\n    if (observer) {\n      observer.refetch();\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  };\n\n  _proto.addObserver = function addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify(this);\n    }\n  };\n\n  _proto.removeObserver = function removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(function (x) {\n        return x !== observer;\n      });\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.retryer.isTransportCancelable) {\n            this.retryer.cancel();\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        if (this.cacheTime) {\n          this.scheduleGc();\n        } else {\n          this.cache.remove(this);\n        }\n      }\n\n      this.cache.notify(this);\n    }\n  };\n\n  _proto.invalidate = function invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  };\n\n  _proto.fetch = function fetch(options, fetchOptions) {\n    var _this2 = this,\n        _this$options$behavio,\n        _context$fetchOptions;\n\n    if (this.state.isFetching) if (this.state.dataUpdatedAt && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {\n      // Silently cancel current fetch if the user wants to cancel refetches\n      this.cancel({\n        silent: true\n      });\n    } else if (this.promise) {\n      // Return current promise if we are already fetching\n      return this.promise;\n    } // Update config if passed, otherwise the config from the last execution is used\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      var observer = this.observers.find(function (x) {\n        return x.options.queryFn;\n      });\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    } // Create query function context\n\n\n    var queryKey = ensureArray(this.queryKey);\n    var queryFnContext = {\n      queryKey: queryKey,\n      pageParam: undefined\n    }; // Create fetch function\n\n    var fetchFn = function fetchFn() {\n      return _this2.options.queryFn ? _this2.options.queryFn(queryFnContext) : Promise.reject('Missing queryFn');\n    }; // Trigger behavior hook\n\n\n    var context = {\n      fetchOptions: fetchOptions,\n      options: this.options,\n      queryKey: queryKey,\n      state: this.state,\n      fetchFn: fetchFn\n    };\n\n    if ((_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch) {\n      var _this$options$behavio2;\n\n      (_this$options$behavio2 = this.options.behavior) == null ? void 0 : _this$options$behavio2.onFetch(context);\n    } // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    } // Try to fetch the data\n\n\n    this.retryer = new Retryer({\n      fn: context.fetchFn,\n      onFail: function onFail() {\n        _this2.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: function onPause() {\n        _this2.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: function onContinue() {\n        _this2.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay\n    });\n    this.promise = this.retryer.promise.then(function (data) {\n      return _this2.setData(data);\n    }).catch(function (error) {\n      // Set error state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        _this2.dispatch({\n          type: 'error',\n          error: error\n        });\n      } // Log error\n\n\n      if (!isCancelledError(error)) {\n        getLogger().error(error);\n      } // Propagate error\n\n\n      throw error;\n    });\n    return this.promise;\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this3 = this;\n\n    this.state = this.reducer(this.state, action);\n    notifyManager.batch(function () {\n      _this3.observers.forEach(function (observer) {\n        observer.onQueryUpdate(action);\n      });\n\n      _this3.cache.notify(_this3);\n    });\n  };\n\n  _proto.getDefaultState = function getDefaultState(options) {\n    var data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n    var hasData = typeof data !== 'undefined';\n    return {\n      data: data,\n      dataUpdateCount: 0,\n      dataUpdatedAt: hasData ? Date.now() : 0,\n      error: null,\n      errorUpdateCount: 0,\n      errorUpdatedAt: 0,\n      fetchFailureCount: 0,\n      fetchMeta: null,\n      isFetching: false,\n      isInvalidated: false,\n      isPaused: false,\n      status: hasData ? 'success' : 'idle'\n    };\n  };\n\n  _proto.reducer = function reducer(state, action) {\n    var _action$meta, _action$dataUpdatedAt;\n\n    switch (action.type) {\n      case 'failed':\n        return _extends({}, state, {\n          fetchFailureCount: state.fetchFailureCount + 1\n        });\n\n      case 'pause':\n        return _extends({}, state, {\n          isPaused: true\n        });\n\n      case 'continue':\n        return _extends({}, state, {\n          isPaused: false\n        });\n\n      case 'fetch':\n        return _extends({}, state, {\n          fetchFailureCount: 0,\n          fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n          isFetching: true,\n          isPaused: false,\n          status: state.status === 'idle' ? 'loading' : state.status\n        });\n\n      case 'success':\n        return _extends({}, state, {\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n          error: null,\n          fetchFailureCount: 0,\n          isFetching: false,\n          isInvalidated: false,\n          isPaused: false,\n          status: 'success'\n        });\n\n      case 'error':\n        var error = action.error;\n\n        if (isCancelledError(error) && error.revert) {\n          return _extends({}, state, {\n            fetchFailureCount: 0,\n            isFetching: false,\n            isPaused: false,\n            status: state.status === 'loading' ? 'idle' : state.status\n          });\n        }\n\n        return _extends({}, state, {\n          error: error,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          isFetching: false,\n          isPaused: false,\n          status: 'error'\n        });\n\n      case 'invalidate':\n        return _extends({}, state, {\n          isInvalidated: true\n        });\n\n      case 'setState':\n        return _extends({}, state, action.state);\n\n      default:\n        return state;\n    }\n  };\n\n  return Query;\n}();"]},"metadata":{},"sourceType":"module"}